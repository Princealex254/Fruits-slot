<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruit Slots</title>
    <style>
        /* CSS Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            color: #eee;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
            align-items: center; /* Center content horizontally */
            /* Added background gradient */
            background: linear-gradient(to bottom, #8e2de2, #4a00e0); /* Purple gradient background */
        }

        .header {
            background-color: #6a0dad; /* Purple */
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
            z-index: 10;
            width: 100%; /* Full width header */
            box-sizing: border-box; /* Include padding in width */
        }

        .account-balance {
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .menu-icon {
            cursor: pointer;
            font-size: 1.8em;
            padding: 0 5px;
            color: #ffeb3b; /* Yellow */
        }

        /* New mobile frame wrapper */
        .mobile-frame {
            width: 100%;
            max-width: 420px; /* narrow like phone screen */
            margin: auto;
            background: #300; /* Dark reddish background for the frame */
            border-radius: 40px; /* Rounded corners for phone shape */
            padding: 5px; /* Reduced padding inside the frame */
            box-shadow: 0 0 20px #000; /* Shadow for depth */
            display: flex; /* To center the game-area-wrapper */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-grow: 1; /* Allow it to grow and take available space */
            min-height: 0; /* Important for flex children */
        }

        /* Main game area container - represents the entire slot machine body */
        .game-area-wrapper {
            flex-grow: 1; /* Allow it to fill the mobile-frame height */
            display: flex;
            flex-direction: column; /* Stack sections vertically */
            align-items: center; /* Center content horizontally */
            width: 100%;
            height: auto; /* Changed to auto to work with content */
            min-height: 0; /* Important for flex items to prevent overflow */
            margin: 0 auto; /* Center within mobile-frame */
            background: linear-gradient(to bottom, #922b2b, #b33939); /* Keep machine color */
            border-radius: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 5px; /* Reduced padding around the internal components */
            box-sizing: border-box;
            border: 5px solid #ffeb3b; /* Gold border for the machine */
        }

        /* Game board - where the fruits spin */
        .game-board {
            position: relative;
            width: 100%; /* Changed to 100% */
            height: auto; /* Changed to auto */
            aspect-ratio: 1 / 1.2; /* Slightly taller than wide */
            max-width: 380px; /* New: Max width for the board itself */
            max-height: unset; /* Removed max-height to allow aspect-ratio to control */
            background: linear-gradient(145deg, #922b2b, #b33939); /* Reddish gradient */
            border-radius: 25px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.9), 0 0 30px rgba(255, 215, 0, 0.7), 0 0 60px rgba(255, 165, 0, 0.5); /* Intense glow */
            display: grid;
            grid-template-columns: repeat(7, 1fr); /* 7 columns for 24 items */
            grid-template-rows: repeat(7, 1fr);    /* 7 rows for 24 items */
            padding: 5px; /* Reduced padding */
            box-sizing: border-box;
            border: 5px solid #ffeb3b; /* Gold border */
            min-width: unset; /* Removed */
            min-height: unset; /* Removed */
            margin-bottom: 5px; /* Reduced space below the board */
        }

        /* Precise positioning for 24 fruits/symbols on a 7x7 grid. */
        /* Order follows user's detailed description, clockwise from top-left. */

        /* Top Row (7 items: 1-7) */
        .slot-item:nth-child(1) { grid-column: 1; grid-row: 1; } /* Big orange image */
        .slot-item:nth-child(2) { grid-column: 2; grid-row: 1; } /* Big bell image */
        .slot-item:nth-child(3) { grid-column: 3; grid-row: 1; } /* Small Bar with small x50 on it */
        .slot-item:nth-child(4) { grid-column: 4; grid-row: 1; } /* Big Bar */
        .slot-item:nth-child(5) { grid-column: 5; grid-row: 1; } /* Apple image (x5) */
        .slot-item:nth-child(6) { grid-column: 6; grid-row: 1; } /* small apple with small x3 on it */
        .slot-item:nth-child(7) { grid-column: 7; grid-row: 1; } /* big mango image (Top-Right Corner) */

        /* Right Column (6 items: 8-13, excluding top-right and bottom-right corners) */
        .slot-item:nth-child(8) { grid-column: 7; grid-row: 2; } /* Big watermelon image */
        .slot-item:nth-child(9) { grid-column: 7; grid-row: 3; } /* small water mellon with x3 on it */
        .slot-item:nth-child(10) { grid-column: 7; grid-row: 4; } /* small tab indicated Lucky */
        .slot-item:nth-child(11) { grid-column: 7; grid-row: 5; } /* image of Apple */
        .slot-item:nth-child(12) { grid-column: 7; grid-row: 6; } /* small orange with x3 written on it */
        .slot-item:nth-child(13) { grid-column: 7; grid-row: 7; } /* Big orange (Bottom-Right Corner) */

        /* Bottom Row (6 items: 14-19, excluding bottom-right and bottom-left corners, reversed order) */
        .slot-item:nth-child(14) { grid-column: 6; grid-row: 7; } /* Big bell image */
        .slot-item:nth-child(15) { grid-column: 5; grid-row: 7; } /* small 7 with x3 on it */
        .slot-item:nth-child(16) { grid-column: 4; grid-row: 7; } /* Big 77 */
        .slot-item:nth-child(17) { grid-column: 3; grid-row: 7; } /* Apple image */
        .slot-item:nth-child(18) { grid-column: 2; grid-row: 7; } /* small mango with x3 on it */
        .slot-item:nth-child(19) { grid-column: 1; grid-row: 7; } /* Big mango (Bottom-Left Corner) */

        /* Left Column (5 items: 20-24) */
        .slot-item:nth-child(20) { grid-column: 1; grid-row: 6; } /* Big double star */
        .slot-item:nth-child(21) { grid-column: 1; grid-row: 5; } /* Small star with x3 on it */
        .slot-item:nth-child(22) { grid-column: 1; grid-row: 4; } /* small tab indicated Lucky */
        .slot-item:nth-child(23) { grid-column: 1; grid-row: 3; } /* Apple image */
        .slot-item:nth-child(24) { grid-column: 1; grid-row: 2; } /* small bell image with x3 on it */


        .slot-item {
            /* Increased font size for larger emojis */
            font-size: 1.6em; /* Slightly reduced font size */
            display: flex;
            flex-direction: column; /* Allow content to stack */
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.08); /* Slightly transparent white */
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2); /* Clearer border */
            position: relative;
            overflow: hidden;
            color: white; /* For BAR/X3/Lucky text */
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: bold;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; /* Smooth highlight */
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); /* Subtle initial glow */
            text-align: center; /* Center text within the slot */
            line-height: 1; /* Tightened line height */
            padding: 0px; /* Removed padding to maximize content space */
            box-sizing: border-box; /* Include padding in element size */
        }

        /* Specific adjustments for text-based symbols */
        .slot-item[data-fruit="big-77-bottom"],
        .slot-item[data-fruit="big-double-star-left"],
        .slot-item[data-fruit="big-bar"],
        .slot-item[data-fruit="small-bar-x50"] {
            font-size: 1.2em; /* Slightly smaller to ensure fit */
        }

        .slot-item span.small-text {
            /* Further reduced font size for multipliers */
            font-size: 0.35em; /* Significantly reduced relative to parent */
            display: block; /* Ensure it's on a new line */
            margin-top: -1px; /* Pull it closer to the emoji */
            color: #ffeb3b; /* Yellow for multipliers */
            text-shadow: none;
        }

        .slot-item.lucky-tab {
            background-color: #3f51b5; /* Blue for Lucky tabs */
            color: white;
            font-size: 0.6em; /* Even smaller font for Lucky tabs */
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 0 10px rgba(63, 81, 181, 0.5);
        }


        .center-display {
            /* Spans columns 2 to 6, and rows 2 to 6, creating a 5x5 center */
            grid-column: 2 / span 5;
            grid-row: 2 / span 5;
            background: linear-gradient(135deg, #6a0dad, #8a2be2); /* Purple gradient */
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1;
            border: 3px solid gold;
        }

        .glowing-label {
            /* Reduced font size for "FRUIT SLOTS" */
            font-size: 1.2em; /* Adjusted to be smaller */
            font-weight: bold;
            color: gold;
            text-shadow: 0 0 15px orange, 0 0 30px yellow, 0 0 45px orange;
            animation: pulse 1.8s infinite alternate ease-in-out;
            letter-spacing: 2px;
        }

        .winning-display {
            font-size: 2.5em; /* Adjusted font size */
            font-weight: bold;
            color: #ccff00; /* Bright green for win numbers */
            margin-top: 5px; /* Reduced margin */
            text-shadow: 0 0 10px #ccff00, 0 0 20px #99ff00;
        }

        /* Highlight animation */
        .slot-item.highlight {
            background-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 25px 7px yellow, inset 0 0 10px yellow;
            transform: scale(1.15); /* More pronounced scale */
            border-color: yellow;
        }

        /* New class for smooth bonus blinking */
        .slot-item.smooth-blink {
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out, box-shadow 0.4s ease-in-out;
            opacity: 0;
            transform: scale(0.9);
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .slot-item.smooth-blink.active {
            opacity: 1;
            transform: scale(1.15);
            box-shadow: 0 0 25px 7px yellow, inset 0 0 10px yellow;
        }

        /* CSS for "dance a bit" */
        @keyframes dance {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .slot-item.dancing {
            animation: dance 0.3s ease-in-out infinite alternate;
        }


        /* Controls area - contains stake info, GO button, and other control buttons */
        .controls-area {
            width: 100%;
            background-color: #922b2b; /* Match machine body color */
            padding: 5px; /* Reduced padding */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 5px; /* Reduced gap */
            border-bottom-left-radius: 25px;
            border-bottom-right-radius: 25px;
            border-top: 2px solid #ffeb3b; /* Gold border at top */
            box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        .top-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* Align stake info to bottom of its container */
            gap: 5px; /* Reduced gap */
        }

        .stake-info {
            flex-grow: 1;
            background-color: #555; /* Darker background for stake info block */
            padding: 5px; /* Reduced padding */
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            font-size: 0.8em; /* Adjusted font size */
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px; /* Reduced gap */
        }
        .stake-info div {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stake-info span {
            font-weight: bold;
            color: #ccff00; /* Bright green for values */
        }
        .stake-info .available-amount {
            font-size: 0.8em; /* Slightly smaller */
            color: #ccc;
        }
        .stake-info .gift-info {
            font-size: 0.7em; /* Slightly smaller */
            color: #ffeb3b;
        }

        .go-button {
            background: linear-gradient(135deg, #ffc107, #ff9800); /* Yellow-orange gradient */
            color: #333;
            padding: 5px 10px; /* Reduced padding for this GO button */
            border: none;
            border-radius: 8px;
            font-size: 1em; /* Reduced font size */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            letter-spacing: 1px;
            text-transform: uppercase;
            width: 90px; /* Reduced width */
            height: 50px; /* Reduced height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 1.1; /* Adjust line height for better stacking */
        }
        .go-button .go-subtext {
            font-size: 0.6em; /* Adjusted font size for visibility */
            font-weight: normal;
            margin-top: 1px; /* Reduced margin to pull closer to main text */
            color: #555;
        }
        .go-button:hover {
            background: linear-gradient(135deg, #ffe082, #ffb300);
            transform: translateY(-3px);
            box-shadow: 0 7px 14px rgba(0, 0, 0, 0.6);
        }
        .go-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .bottom-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 3px; /* Even smaller gap */
            background-color: #555; /* Background for this row of buttons */
            padding: 5px; /* Reduced padding */
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .control-button {
            background-color: #007bff; /* Blue */
            color: white;
            padding: 5px 8px; /* Reduced padding */
            border: none;
            border-radius: 5px; /* Slightly smaller radius */
            font-size: 0.75em; /* Smaller font */
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
            flex-grow: 1;
            min-width: 45px; /* Ensure buttons don't get too small */
            text-transform: uppercase;
        }
        .control-button.arrow-button {
            font-size: 1em; /* Slightly smaller arrows */
            padding: 5px 10px;
        }
        .control-button.range-button {
            background-color: #ffc107; /* Yellow for range buttons */
            color: #333;
        }
        #all-x1 { background-color: #28a745; } /* Green */
        #clear-selection { background-color: #dc3545; } /* Red */

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        #all-x1:hover { background-color: #218838; }
        #clear-selection:hover { background-color: #c82333; }
        .control-button.range-button:hover { background-color: #e0a800; }


        /* Fruit Selection Grid Styling */
        .fruit-selection-grid {
            display: flex; /* Changed to flexbox */
            flex-wrap: nowrap; /* Prevent wrapping */
            overflow-x: auto; /* Enable horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            gap: 3px; /* Even smaller gap between buttons */
            padding: 5px; /* Reduced padding */
            background-color: #922b2b; /* Match machine body color */
            border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            border: 2px solid #ffeb3b; /* Gold border */
            width: 100%;
            box-sizing: border-box;
            margin-top: 5px; /* Reduced space from controls-area */
            justify-content: flex-start; /* Align items to the start */
            align-items: center; /* Center items vertically */
        }

        .fruit-selection-grid::-webkit-scrollbar {
            height: 8px; /* Height of the scrollbar */
        }

        .fruit-selection-grid::-webkit-scrollbar-track {
            background: #444; /* Color of the scrollbar track */
            border-radius: 10px;
        }

        .fruit-selection-grid::-webkit-scrollbar-thumb {
            background: #888; /* Color of the scrollbar thumb */
            border-radius: 10px;
        }

        .fruit-selection-grid::-webkit-scrollbar-thumb:hover {
            background: #555; /* Color of the scrollbar thumb on hover */
        }

        .fruit-selection-grid .fruit-button {
            flex-shrink: 0; /* Prevent buttons from shrinking */
            width: 55px; /* Further reduced width for consistency */
            height: 55px; /* Further reduced height for consistency */
            background-color: #28a745; /* Green background for selection buttons */
            color: white;
            padding: 3px 1px; /* Reduced padding */
            border: 2px solid #ffeb3b; /* Gold border */
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em; /* Adjusted emoji size */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Space between emoji and count */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .fruit-selection-grid .fruit-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .fruit-selection-grid .fruit-button .selection-count {
            font-size: 0.6em; /* Size for 00, 01, 02 */
            font-weight: bold;
            color: #ccff00; /* Bright green for count */
            background-color: rgba(0, 0, 0, 0.4);
            padding: 1px 4px; /* Reduced padding */
            border-radius: 5px;
            margin-top: 1px; /* Reduced margin */
            min-width: 18px; /* Ensure consistent width */
            text-align: center;
        }


        /* History area - hidden as per image, but kept for potential future use */
        .history-area {
            display: none; /* Hidden as per the provided image */
            width: 100%;
            max-width: 650px;
            margin-top: 20px;
            padding: 20px;
            background-color: #333;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
            margin-bottom: 20px;
            border: 1px solid #555;
            box-sizing: border-box;
        }

        .history-area h3 {
            text-align: center;
            margin-top: 0;
            color: #ffeb3b;
            font-size: 1.5em;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        #history-list {
            list-style: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        #history-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #444;
            font-size: 0.95em;
            color: #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #history-list li:last-child {
            border-bottom: none;
        }

        #history-list::-webkit-scrollbar {
            width: 8px;
        }
        #history-list::-webkit-scrollbar-track {
            background: #3a3a3a;
            border-radius: 10px;
        }
        #history-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #history-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }


        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; text-shadow: 0 0 15px orange, 0 0 30px yellow, 0 0 45px orange; }
            50% { transform: scale(1.03); opacity: 0.95; text-shadow: 0 0 20px orange, 0 0 40px yellow, 0 0 60px orange; }
            100% { transform: scale(1); opacity: 1; text-shadow: 0 0 15px orange, 0 0 30px yellow, 0 0 45px orange; }
        }


        /* Media Queries for Responsiveness */

        /* Mobile (vertical layout) - Default styles */
        /* The initial styles are optimized for mobile. */

        /* Desktop (wider screens) */
        @media (min-width: 768px) {
            .mobile-frame {
                max-width: 420px; /* Keep consistent with mobile-first approach */
                padding: 10px; /* Adjusted padding for consistency */
            }

            .game-area-wrapper {
                max-width: 420px; /* Keep consistent with mobile-first approach */
                padding: 10px; /* Adjusted padding for consistency */
            }

            .game-board {
                width: 100%; /* Keep 100% */
                height: auto; /* Keep auto */
                aspect-ratio: 1 / 1.2; /* Slightly taller than wide */
                max-width: 380px; /* Keep consistent with game-area-wrapper */
                padding: 10px; /* Adjusted padding for consistency */
                margin-bottom: 10px; /* Keep reduced margin */
            }

            .slot-item {
                font-size: 1.8em; /* Adjusted to match mobile size, as desktop is now constrained */
            }

            .slot-item span.small-text {
                font-size: 0.4em; /* Adjusted to match mobile size */
            }

            .glowing-label {
                font-size: 1.4em; /* Adjusted to match mobile size */
            }

            .winning-display {
                font-size: 2.8em; /* Adjusted to match mobile size */
            }

            .controls-area {
                padding: 10px; /* Adjusted padding for consistency */
                gap: 10px; /* Adjusted gap */
            }

            .fruit-selection-grid {
                flex-wrap: wrap; /* Allow wrapping on larger screens if desired */
                overflow-x: hidden; /* Hide scrollbar if not needed on wider screens */
                justify-content: center; /* Center buttons on wider screens */
                gap: 5px; /* Adjusted gap */
                padding: 10px; /* Adjusted padding */
                margin-top: 10px; /* Keep reduced margin */
            }

            .fruit-selection-grid .fruit-button {
                width: 80px; /* Slightly larger buttons on desktop */
                height: 70px;
                font-size: 1.3em;
                padding: 5px 3px; /* Adjusted padding */
            }
            .fruit-selection-grid .fruit-button .selection-count {
                font-size: 0.8em;
                padding: 2px 8px; /* Adjusted padding */
                margin-top: 3px; /* Adjusted margin */
            }
        }

        @media (min-width: 1024px) {
            .mobile-frame {
                max-width: 420px; /* Keep consistent, as this is a mobile-app like layout */
            }
            .game-area-wrapper {
                max-width: 420px; /* Keep consistent, as this is a mobile-app like layout */
            }
            .game-board {
                max-width: 380px; /* Keep consistent */
            }
        }
    </style>
    <!-- Tone.js for sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="account-balance">Account Balance: KES <span id="balance">10,000.00</span></div>
        <div class="menu-icon">&#9776;</div>
    </header>

    <div class="mobile-frame">
        <main class="game-area-wrapper">
            <div class="game-board">
                <!-- The game-board itself is the grid container. -->
                <!-- The 24 slot items are arranged clockwise from top-left, matching the image. -->
                <!-- Each item's data-fruit attribute corresponds to a key in the fruitsData object in JavaScript. -->
                <!-- Top Row (1-7) -->
                <div class="slot-item" data-fruit="big-orange-top-left">üçä</div> <!-- 1 -->
                <div class="slot-item" data-fruit="big-bell-top">üîî</div> <!-- 2 -->
                <div class="slot-item" data-fruit="small-bar-x50">BAR<span class="small-text">x50</span></div> <!-- 3 -->
                <div class="slot-item" data-fruit="big-bar">BAR</div> <!-- 4 -->
                <div class="slot-item" data-fruit="apple-x5">üçé<span class="small-text">x5</span></div> <!-- 5 -->
                <div class="slot-item" data-fruit="small-apple-x3-top">üçé<span class="small-text">x3</span></div> <!-- 6 -->
                <div class="slot-item" data-fruit="big-mango-top-right">ü•≠</div> <!-- 7 -->

                <!-- Right Column (6 items: 8-13, excluding top-right and bottom-right corners) -->
                <div class="slot-item" data-fruit="big-watermelon-right">üçâ</div> <!-- 8 -->
                <div class="slot-item" data-fruit="small-watermelon-x3-right">üçâ<span class="small-text">x3</span></div> <!-- 9 -->
                <div class="slot-item lucky-tab" data-fruit="lucky-tab-right">LUCKY</div> <!-- 10 -->
                <div class="slot-item" data-fruit="apple-right-middle">üçé</div> <!-- 11 -->
                <div class="slot-item" data-fruit="small-orange-x3-right">üçä<span class="small-text">x3</span></div> <!-- 12 -->
                <div class="slot-item" data-fruit="big-orange-bottom-right">üçä</div> <!-- 13 -->

                <!-- Bottom Row (6 items: 14-19, excluding bottom-right and bottom-left corners, reversed order) -->
                <div class="slot-item" data-fruit="big-bell-bottom">üîî</div> <!-- 14 -->
                <div class="slot-item" data-fruit="small-7-x3-bottom">7Ô∏è‚É£<span class="small-text">x3</span></div> <!-- 15 -->
                <div class="slot-item" data-fruit="big-77-bottom">7Ô∏è‚É£7Ô∏è‚É£</div> <!-- 16 -->
                <div class="slot-item" data-fruit="apple-bottom-middle">üçé</div> <!-- 17 -->
                <div class="slot-item" data-fruit="small-mango-x3-bottom">ü•≠<span class="small-text">x3</span></div> <!-- 18 -->
                <div class="slot-item" data-fruit="big-mango-bottom-left">ü•≠</div> <!-- 19 -->

                <!-- Left Column (5 items: 20-24) -->
                <div class="slot-item" data-fruit="big-double-star-left">‚≠ê‚≠ê</div> <!-- 20 -->
                <div class="slot-item" data-fruit="small-star-x3-left">‚≠ê<span class="small-text">x3</span></div> <!-- 21 -->
                <div class="slot-item lucky-tab" data-fruit="lucky-tab-left">LUCKY</div> <!-- 22 -->
                <div class="slot-item" data-fruit="apple-left-middle">üçé</div> <!-- 23 -->
                <div class="slot-item" data-fruit="small-bell-x3-left">üîî<span class="small-text">x3</span></div> <!-- 24 -->

                <!-- Center Display -->
                <div class="center-display">
                    <div class="glowing-label">FRUIT SLOTS</div>
                    <div class="winning-display">00</div>
                </div>
            </div>

            <div class="controls-area">
                <div class="top-controls">
                    <div class="stake-info">
                        <div class="stake-amount">
                            Stake: <span>0.00</span>
                        </div>
                        <div class="win-info">
                            Win: <span>0.00</span>
                        </div>
                        <div class="available-amount">
                            KSH <span id="available-balance">10000.00</span> Available
                        </div>
                        <div class="gift-info">
                            üéÅ Gift
                        </div>
                    </div>
                    <button id="go-button" class="go-button">GO<br><span class="go-subtext">About to Pay 0</span></button>
                </div>

                <div class="bottom-controls">
                    <button id="all-x1" class="control-button">ALL+1</button>
                    <button class="control-button arrow-button left-arrow">‚Üê</button>
                    <button class="control-button arrow-button right-arrow">‚Üí</button>
                    <button class="control-button range-button">1-7</button>
                    <button class="control-button range-button">8-14</button>
                    <button id="clear-selection" class="control-button">CLEAR</button>
                </div>
            </div>

            <!-- Fruit Selection Grid (Moved to be below controls-area, inside game-area-wrapper) -->
            <div class="fruit-selection-grid">
                <!-- Buttons will be dynamically populated here by JavaScript -->
            </div>
        </main>
    </div>

    <!-- History area - hidden as per image, but kept for potential future use -->
    <div class="history-area">
        <h3>Last Results</h3>
        <ul id="history-list">
            <!-- History items will be added here by JS -->
        </ul>
    </div>

    <script>
        // JavaScript Logic
        document.addEventListener('DOMContentLoaded', () => {
            const balanceDisplay = document.getElementById('balance');
            const currentStakeDisplay = document.querySelector('.stake-amount span');
            const currentWinDisplay = document.querySelector('.win-info span');
            const availableBalanceDisplay = document.getElementById('available-balance');
            const goSubtext = document.querySelector('.go-subtext');
            const allX1Button = document.getElementById('all-x1');
            const clearSelectionButton = document.getElementById('clear-selection');
            const fruitSelectionGrid = document.querySelector('.fruit-selection-grid');
            const goButton = document.getElementById('go-button');
            const historyList = document.getElementById('history-list');
            const slotItems = Array.from(document.querySelectorAll('.slot-item'));
            const winningDisplay = document.querySelector('.winning-display');

            // Initialize Tone.js Synth for sound effects
            const synth = new Tone.Synth().toDestination();

            // Create a polyphonic synth for simultaneous notes (for hit sounds)
            const polySynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.02, decay: 0.1, sustain: 0.1, release: 0.2 }
            }).toDestination();

            // Background Music (simple ambient loop)
            const bgSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 2, decay: 1, sustain: 0.5, release: 2 }
            }).toDestination();

            const bgMelody = new Tone.Sequence((time, note) => {
                bgSynth.triggerAttackRelease(note, "4n", time);
            }, ["C3", "E3", "G3", "A3", "G3", "E3"]); // Simple repeating melody
            bgMelody.loop = true;
            bgMelody.playbackRate = 0.5; // Slower tempo for ambient feel

            // Start background music when the document is ready
            Tone.start().then(() => {
                bgMelody.start();
            }).catch(e => console.error("Tone.js audio start failed:", e));


            // Create a simple oscillator for the continuous moving sound
            const movingOscillator = new Tone.Oscillator().toDestination();
            movingOscillator.frequency.value = 440; // A4 note
            movingOscillator.type = "sine"; // Changed to sine for smoother sound
            movingOscillator.volume.value = -25; // Further reduced volume
            movingOscillator.detune.value = 0; // No detune for a cleaner sound

            // New synth for bonus blinking sound
            const bonusBlinkSynth = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
            }).toDestination();

            // New synth for the dancing/blinking phase sound in X3 bonus
            const dancingSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
            }).toDestination();
            const dancingSequence = new Tone.Sequence((time, note) => {
                dancingSynth.triggerAttackRelease(note, "8n", time);
            }, ["C4", "E4", "G4", "A4"]); // Loop a simple arpeggio
            dancingSequence.loop = true;
            dancingSequence.playbackRate = 1;


            // New Tone.js elements for bonus music - REMOVED .toDestination()
            const x3BonusSequence = new Tone.Sequence((time, note) => {
                polySynth.triggerAttackRelease(note, "8n", time);
            }, ["C5", "E5", "G5", "C6"]);
            x3BonusSequence.loop = 0; // Play once
            x3BonusSequence.playbackRate = 2; // Make it fast

            const bigFruitBonusChord = new Tone.PolySynth(Tone.Synth).toDestination();

            const fullBoardSequence = new Tone.Sequence((time, note) => {
                polySynth.triggerAttackRelease(note, "16n", time);
            }, ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"]);
            fullBoardSequence.loop = 0;
            fullBoardSequence.playbackRate = 3; // Very fast

            const appleBonusMelody = new Tone.Sequence((time, note) => {
                polySynth.triggerAttackRelease(note, "8n", time);
            }, ["C5", "G4", "E4", "C4"]);
            appleBonusMelody.loop = 0;
            appleBonusMelody.playbackRate = 1.5;

            let accountBalance = 10000.00;
            let selectedFruits = {}; // { categoryName: count (1 to MAX_FRUIT_STAKE_MULTIPLIER) }
            let currentStake = 0;
            let currentBetAmount = 10; // Default bet amount
            const MAX_FRUIT_STAKE_MULTIPLIER = 5; // Maximum multiplier for a single fruit selection

            // Global variable to hold the blinking interval ID for bonus mode
            let bonusBlinkInterval = null;

            // Define all fruits on the board with their specific properties and category
            const fruitsData = {
                // Top Row
                'big-orange-top-left': { emoji: 'ÔøΩ', multiplier: [10, 20], type: 'range', category: 'orange' },
                'big-bell-top': { emoji: 'üîî', multiplier: [10, 20], type: 'range', category: 'bell' },
                'small-bar-x50': { emoji: 'BAR', multiplier: 50, type: 'fixed', category: 'bar' }, // Updated multiplier
                'big-bar': { emoji: 'BAR', multiplier: 100, type: 'fixed', category: 'bar' }, // Updated multiplier
                'apple-x5': { emoji: 'üçé', multiplier: 5, type: 'fixed', category: 'apple' },
                'small-apple-x3-top': { emoji: 'üçé', multiplier: 3, type: 'fixed', category: 'apple' },
                'big-mango-top-right': { emoji: 'ü•≠', multiplier: [10, 20], type: 'range', category: 'mango' },

                // Right Column
                'big-watermelon-right': { emoji: 'üçâ', multiplier: [20, 40], type: 'range', category: 'watermelon' },
                'small-watermelon-x3-right': { emoji: 'üçâ', multiplier: 3, type: 'fixed', category: 'watermelon' },
                'lucky-tab-right': { emoji: 'LUCKY', multiplier: 0, type: 'lucky', category: 'lucky-tab' },
                'apple-right-middle': { emoji: 'üçé', multiplier: 5, type: 'fixed', category: 'apple' },
                'small-orange-x3-right': { emoji: 'üçä', multiplier: 3, type: 'fixed', category: 'orange' },
                'big-orange-bottom-right': { emoji: 'üçä', multiplier: [10, 20], type: 'range', category: 'orange' },

                // Bottom Row
                'big-bell-bottom': { emoji: 'üîî', multiplier: [10, 20], type: 'range', category: 'bell' },
                'small-7-x3-bottom': { emoji: '7Ô∏è‚É£', multiplier: 3, type: 'fixed', category: '7' },
                'big-77-bottom': { emoji: '7Ô∏è‚É£7Ô∏è‚É£', multiplier: [20, 40], type: 'range', category: '7' },
                'apple-bottom-middle': { emoji: 'üçé', multiplier: 5, type: 'fixed', category: 'apple' },
                'small-mango-x3-bottom': { emoji: 'ü•≠', multiplier: 3, type: 'fixed', category: 'mango' },
                'big-mango-bottom-left': { emoji: 'ü•≠', multiplier: [10, 20], type: 'range', category: 'mango' },

                // Left Column
                'big-double-star-left': { emoji: '‚≠ê‚≠ê', multiplier: [20, 40], type: 'range', category: 'star' },
                'small-star-x3-left': { emoji: '‚≠ê', multiplier: 3, type: 'fixed', category: 'star' },
                'lucky-tab-left': { emoji: 'LUCKY', multiplier: 0, type: 'lucky', category: 'lucky-tab' },
                'apple-left-middle': { emoji: 'üçé', multiplier: 5, type: 'fixed', category: 'apple' },
                'small-bell-x3-left': { emoji: 'üîî', multiplier: 3, type: 'fixed', category: 'bell' }
            };

            // Define the categories for the betting grid
            const bettingCategories = [
                { key: 'bar', emoji: 'BAR' },
                { key: '7', emoji: '7Ô∏è‚É£' },
                { key: 'star', emoji: '‚≠ê' },
                { key: 'watermelon', emoji: 'üçâ' },
                { key: 'bell', emoji: 'üîî' },
                { key: 'mango', emoji: 'ü•≠' },
                { key: 'orange', emoji: 'üçä' },
                { key: 'apple', emoji: 'üçé' }
            ];

            // Mapping for fruit hit sounds (musical interpretation of "saying" the fruit name)
            const fruitHitSounds = {
                'bar': "C4",
                '7': "D4",
                'star': "E4",
                'watermelon': "F4",
                'bell': "G4",
                'mango': "A4",
                'orange': "B4",
                'apple': "C5",
                'lucky-tab': "G5" // Special sound for lucky tab
            };

            // Mapping for more readable fruit names for history
            const fruitDisplayNames = {
                'orange': 'Orange',
                'bell': 'Bell',
                'bar': 'BAR',
                'apple': 'Apple',
                'mango': 'Mango',
                'watermelon': 'Watermelon',
                '7': 'Seven',
                'star': 'Star',
                'lucky-tab': 'Lucky Tab'
            };

            // Get a list of all bettable fruit data names (from fruitsData keys) for lucky bonus
            const allBettableFruitDataNames = Object.keys(fruitsData).filter(key =>
                fruitsData[key].type !== 'lucky' && fruitsData[key].type !== 'display'
            );

            const barFruitDataNames = allBettableFruitDataNames.filter(key => fruitsData[key].category === 'bar');
            const nonBarFruitDataNames = allBettableFruitDataNames.filter(key => fruitsData[key].category !== 'bar');


            /**
             * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
             * @param {Array} array The array to shuffle.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
            }

            /**
             * Generates a path that includes full cycles around the board before reaching the target.
             * @param {number} startIndex The starting index of the light.
             * @param {number} endIndex The target index of the light.
             * @param {number} totalItems The total number of items on the board.
             * @param {number} fullCycles The number of full cycles to complete before heading to the target.
             * @returns {Array<number>} An array of indices representing the path.
             */
            function generateLongPath(startIndex, endIndex, totalItems, fullCycles) {
                const path = [];
                let current = startIndex;

                // Add full cycles
                for (let i = 0; i < fullCycles * totalItems; i++) {
                    current = (current + 1) % totalItems; // Always clockwise for full cycles
                    path.push(current);
                }

                // Add the shortest path from the current position to the endIndex
                const shortestPath = [];
                let tempCurrent = current;
                // Determine direction (clockwise or counter-clockwise) for shortest path
                const clockwiseDist = (endIndex - tempCurrent + totalItems) % totalItems;
                const counterClockwiseDist = (tempCurrent - endIndex + totalItems) % totalItems;

                let stepsToTake;
                let direction;

                if (clockwiseDist <= counterClockwiseDist) {
                    stepsToTake = clockwiseDist;
                    direction = 1; // Clockwise
                } else {
                    stepsToTake = counterClockwiseDist;
                    direction = -1; // Counter-clockwise
                }

                for (let i = 0; i < stepsToTake; i++) {
                    tempCurrent = (tempCurrent + direction + totalItems) % totalItems;
                    shortestPath.push(tempCurrent);
                }

                return path.concat(shortestPath);
            }


            // Initialize fruit selection buttons for the new grid
            function initializeFruitButtons() {
                bettingCategories.forEach(category => {
                    const button = document.createElement('button');
                    button.classList.add('fruit-button');
                    button.dataset.category = category.key; // Use data-category for betting
                    // Only emoji and selection count
                    button.innerHTML = `${category.emoji}<br><span class="selection-count">00</span>`;
                    button.addEventListener('click', () => toggleFruitSelection(category.key));
                    fruitSelectionGrid.appendChild(button);
                });
            }

            function updateDisplay() {
                balanceDisplay.textContent = accountBalance.toFixed(2);
                currentStakeDisplay.textContent = currentStake.toFixed(2);
                availableBalanceDisplay.textContent = accountBalance.toFixed(2);
                goSubtext.textContent = `About to Pay ${currentStake.toFixed(0)}`;
            }

            function calculateStake() {
                let stake = 0;
                for (const category in selectedFruits) {
                    stake += selectedFruits[category] * currentBetAmount;
                }
                currentStake = stake;
                updateDisplay();
            }

            function toggleFruitSelection(categoryName) {
                const button = fruitSelectionGrid.querySelector(`[data-category="${categoryName}"]`);
                if (!button) return;

                const selectionCountSpan = button.querySelector('.selection-count');
                let currentMultiplier = selectedFruits[categoryName] || 0;

                if (currentMultiplier < MAX_FRUIT_STAKE_MULTIPLIER) {
                    selectedFruits[categoryName] = currentMultiplier + 1;
                    selectionCountSpan.textContent = (currentMultiplier + 1).toString().padStart(2, '0');
                    button.classList.add('selected');
                } else {
                    // If already at max, reset to 0 (unselect)
                    delete selectedFruits[categoryName];
                    button.classList.remove('selected');
                    selectionCountSpan.textContent = '00';
                }
                calculateStake();
            }

            // This function now takes the exact data-fruit name from the board
            function calculateSingleFruitWin(hitFruitDataName, betMultiplier) {
                const fruitInfo = fruitsData[hitFruitDataName];
                if (!fruitInfo || fruitInfo.type === 'lucky' || fruitInfo.type === 'display') return 0;

                let stakeMultiplier = 0;
                if (fruitInfo.type === 'fixed') {
                    stakeMultiplier = fruitInfo.multiplier;
                } else if (fruitInfo.type === 'range') {
                    // Custom logic for range multipliers
                    if (fruitInfo.category === 'orange' || fruitInfo.category === 'mango' || fruitInfo.category === 'bell') {
                        // Big Mango / Orange / Bell: 10x fixed, 5% chance for 15x or 20x
                        stakeMultiplier = Math.random() < 0.05 ? [15, 20][Math.floor(Math.random() * 2)] : 10; // Changed from 0.2 to 0.05
                    } else { // 'star', '7', 'watermelon'
                        // Big Double Star, Big 77, Big Watermelon: 20x fixed, 5% chance for 30x or 40x
                        stakeMultiplier = Math.random() < 0.05 ? [30, 40][Math.floor(Math.random() * 2)] : 20; // Changed from 0.2 to 0.05
                    }
                }
                return stakeMultiplier * currentBetAmount * betMultiplier;
            }

            allX1Button.addEventListener('click', () => {
                let anyChange = false;
                bettingCategories.forEach(category => {
                    const categoryKey = category.key;
                    const button = fruitSelectionGrid.querySelector(`[data-category="${categoryKey}"]`);
                    if (!button) return;

                    const selectionCountSpan = button.querySelector('.selection-count');
                    let currentMultiplier = selectedFruits[categoryKey] || 0;

                    if (currentMultiplier < MAX_FRUIT_STAKE_MULTIPLIER) {
                        selectedFruits[categoryKey] = currentMultiplier + 1;
                        selectionCountSpan.textContent = (currentMultiplier + 1).toString().padStart(2, '0');
                        button.classList.add('selected');
                        anyChange = true;
                    }
                });
                if (anyChange) {
                    calculateStake();
                }
            });


            clearSelectionButton.addEventListener('click', () => {
                selectedFruits = {};
                const fruitButtons = fruitSelectionGrid.querySelectorAll('.fruit-button');
                fruitButtons.forEach(button => {
                    button.classList.remove('selected');
                    button.querySelector('.selection-count').textContent = '00';
                });
                calculateStake();
            });

            goButton.addEventListener('click', spin);

            let totalWinAmount = 0; // Global to accumulate wins across bonus functions
            let hitFruitsForBlink = []; // Global to store fruits that should blink at the end

            async function spin() {
                // Stop any previous bonus blinking and clear highlights from all items
                if (bonusBlinkInterval) {
                    clearInterval(bonusBlinkInterval);
                    bonusBlinkInterval = null;
                }
                slotItems.forEach(item => {
                    item.classList.remove('highlight');
                    item.classList.remove('smooth-blink', 'active'); // Ensure smooth-blink classes are removed
                    item.classList.remove('dancing'); // Ensure dancing class is removed
                    // Clear any individual blink intervals
                    if (item.dataset.individualBlinkId) {
                        clearInterval(item.dataset.individualBlinkId);
                        delete item.dataset.individualBlinkId;
                    }
                });
                totalWinAmount = 0; // Reset total win for new spin
                hitFruitsForBlink = []; // Reset hit fruits for new spin


                if (currentStake === 0) {
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #333; color: white; padding: 20px; border-radius: 10px;
                        box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 1000; text-align: center;
                        font-size: 1.1em;
                    `;
                    messageBox.textContent = 'Please select fruits to bet on.';
                    document.body.appendChild(messageBox);
                    setTimeout(() => {
                        document.body.removeChild(messageBox);
                    }, 2000);
                    return;
                }
                if (accountBalance < currentStake) {
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #333; color: white; padding: 20px; border-radius: 10px;
                        box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 1000; text-align: center;
                        font-size: 1.1em;
                    `;
                    messageBox.textContent = 'Insufficient balance. Current balance: KES ' + accountBalance.toFixed(2);
                    document.body.appendChild(messageBox);
                    setTimeout(() => {
                        document.body.removeChild(messageBox);
                    }, 2000);
                    return;
                }

                goButton.disabled = true;
                accountBalance -= currentStake;
                updateDisplay();
                currentWinDisplay.textContent = '0.00';
                winningDisplay.textContent = '00';

                // Determine game modes
                // Removed isBarBonusMode from here, as it's now handled within handleNormalSpin
                const isSpecialMode = Math.random() < 0.08; // Existing bonus, 8% chance

                if (isSpecialMode) {
                    await handleSpecialModeBonus();
                } else {
                    await handleNormalSpin();
                }

                // This block runs AFTER the chosen bonus/spin handler completes
                accountBalance += totalWinAmount;
                currentWinDisplay.textContent = totalWinAmount.toFixed(2);
                winningDisplay.textContent = totalWinAmount > 0 ? totalWinAmount.toFixed(0) : '00';
                updateDisplay();
                goButton.disabled = false;

                // Start blinking for the hit fruit(s) after the game round is fully processed
                if (hitFruitsForBlink.length > 0) {
                    let blink = false;
                    bonusBlinkInterval = setInterval(() => {
                        blink = !blink;
                        hitFruitsForBlink.forEach(fruit => {
                            if (blink) {
                                fruit.classList.add('highlight');
                            } else {
                                fruit.classList.remove('highlight');
                            }
                        });
                    }, 500); // Blinks every 500ms
                }
            }

            // --- Bonus Handling Functions ---

            async function handleSpecialModeBonus() {
                addHistory("SPECIAL MODE: Animation + Bonus!");

                // 1. Full Board Blinking Light-Up for 5 seconds (smooth blinking)
                await Tone.start();
                let blinkState = false;
                const blinkIntervalTime = 400;
                const initialBlinkDuration = 5000;

                slotItems.forEach(item => item.classList.add('smooth-blink'));

                const initialBlinkIntervalId = setInterval(() => {
                    blinkState = !blinkState;
                    slotItems.forEach((item, index) => {
                        if (blinkState) {
                            item.classList.add('active');
                            bonusBlinkSynth.triggerAttackRelease("C5", "32n", Tone.context.currentTime + (index * 0.001));
                        } else {
                            item.classList.remove('active');
                        }
                    });
                }, blinkIntervalTime / 2);

                addHistory("Board Blinking for 5 seconds!");
                await new Promise(res => setTimeout(res, initialBlinkDuration));
                clearInterval(initialBlinkIntervalId);
                slotItems.forEach(item => {
                    item.classList.remove('active');
                    item.classList.remove('smooth-blink');
                });

                await Tone.start();
                synth.triggerAttackRelease("D4", "16n");

                const animationType = Math.floor(Math.random() * 4); // 0‚Äì3

                if (animationType === 0) {
                    await handleX3BonusSequence();
                } else if (animationType === 1) {
                    await handleBigFruitsBonusSequence();
                } else if (animationType === 2) {
                    await handleFullBoardPayoutBonus(); // Updated logic
                } else if (animationType === 3) {
                    await handleAllApplesBonusSequence();
                }
            }

            // This function is no longer called from `spin()` directly.
            // It was replaced by `handleNormalSpinBarBonus` for the 1% chance BAR bonus.
            // Keeping it here for reference/if it's used elsewhere, but it's effectively unused by the main spin flow now.
            async function handleBarBonus() {
                addHistory("BAR BONUS: Two BARs light up!"); // This log might be misleading now
                goButton.disabled = true;

                const barElements = slotItems.filter(item => fruitsData[item.dataset.fruit].category === 'bar');

                let blinkState = false;
                const barBlinkIntervalId = setInterval(() => {
                    blinkState = !blinkState;
                    barElements.forEach((item, index) => {
                        if (blinkState) {
                            item.classList.add('highlight');
                            bonusBlinkSynth.triggerAttackRelease("G4", "32n", Tone.context.currentTime + (index * 0.001));
                        } else {
                            item.classList.remove('highlight');
                        }
                    });
                }, 300);

                await new Promise(res => setTimeout(res, 5000));
                clearInterval(barBlinkIntervalId);
                barElements.forEach(item => item.classList.remove('highlight'));

                addHistory("BAR Bonus: Light moving for random fruits!");

                const numHits = Math.floor(Math.random() * 3) + 2; // 2-4 fruits
                const potentialLuckyFruits = allBettableFruitDataNames.filter(name => fruitsData[name].category !== 'bar');
                shuffleArray(potentialLuckyFruits);

                let currentLightIndex = slotItems.indexOf(barElements[0]);

                for (let i = 0; i < numHits; i++) {
                    if (potentialLuckyFruits.length === 0) break;

                    const targetFruitDataName = potentialLuckyFruits.pop();
                    const targetFruitElement = slotItems.find(item => item.dataset.fruit === targetFruitDataName);
                    if (!targetFruitElement) continue;

                    const targetIndex = slotItems.indexOf(targetFruitElement);
                    const path = generateLongPath(currentLightIndex, targetIndex, slotItems.length, 1.5);

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75));
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    targetFruitElement.classList.add('highlight');
                    hitFruitsForBlink.push(targetFruitElement);

                    await Tone.start();
                    synth.triggerAttackRelease("E5", "16n", Tone.context.currentTime);
                    playFruitHitSound(fruitsData[targetFruitDataName].category);
                    await new Promise(res => setTimeout(res, 100));

                    const hitFruitCategory = fruitsData[targetFruitDataName].category;
                    if (selectedFruits[hitFruitCategory]) {
                        const bonus = calculateSingleFruitWin(targetFruitDataName, selectedFruits[hitFruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`üí∞ BAR BONUS HIT ‚Üí ${fruitsData[targetFruitDataName].emoji} +KES ${bonus.toFixed(2)}`);
                    } else {
                        addHistory(`üí∞ BAR BONUS MISS ‚Üí ${fruitsData[targetFruitDataName].emoji} (Not Staked)`);
                    }
                    currentLightIndex = targetIndex;
                }
            }

            async function handleX3BonusSequence() {
                addHistory("Bonus Round: x3 Fruits!");
                x3BonusSequence.start();
                const x3Fruits = slotItems.filter(item => item.innerHTML.includes('x3'));
                let currentLightIndex = slotItems.indexOf(slotItems[0]); // Start from a default position

                for (let fruitEl of x3Fruits) {
                    const targetIndex = slotItems.indexOf(fruitEl);
                    const path = generateLongPath(currentLightIndex, targetIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75));
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    fruitEl.classList.add('highlight');
                    hitFruitsForBlink.push(fruitEl);
                    await new Promise(res => setTimeout(res, 10));
                    synth.triggerAttackRelease("E5", "32n");
                    await new Promise(res => setTimeout(res, 100));

                    const hitFruitDataName = fruitEl.dataset.fruit;
                    const fruitCategory = fruitsData[hitFruitDataName].category;

                    if (selectedFruits[fruitCategory]) {
                        const bonus = calculateSingleFruitWin(hitFruitDataName, selectedFruits[fruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`‚ú® BONUS x3 ‚Üí ${fruitsData[hitFruitDataName].emoji} +KES ${bonus.toFixed(2)}`);
                        playFruitHitSound(fruitCategory);
                    }
                    currentLightIndex = targetIndex; // Update current index for next path
                }
                x3BonusSequence.stop();
            }

            async function handleBigFruitsBonusSequence() {
                addHistory("Bonus Round: Big Fruits!");
                bigFruitBonusChord.triggerAttackRelease(["C4", "E4", "G4"], "1s");

                const targetFruitDataNames = [
                    'big-orange-top-left',
                    'big-mango-top-right',
                    'big-bell-top'
                ];
                const targetElements = targetFruitDataNames.map(name =>
                    slotItems.find(item => item.dataset.fruit === name)
                ).filter(Boolean);

                let currentLightIndex = slotItems.indexOf(slotItems[0]); // Start from a default position

                for (let el of targetElements) {
                    const targetIndex = slotItems.indexOf(el);
                    const path = generateLongPath(currentLightIndex, targetIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75));
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    el.classList.add('highlight');
                    hitFruitsForBlink.push(el);

                    await Tone.start();
                    synth.triggerAttackRelease("G4", "16n");
                    await new Promise(res => setTimeout(res, 150));

                    const hitFruitDataName = el.dataset.fruit;
                    const fruitCategory = fruitsData[hitFruitDataName].category;

                    if (selectedFruits[fruitCategory]) {
                        const bonus = calculateSingleFruitWin(hitFruitDataName, selectedFruits[fruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`‚ú® BONUS Big Fruit ‚Üí ${fruitsData[hitFruitDataName].emoji} +KES ${bonus.toFixed(2)}`);
                        playFruitHitSound(fruitCategory);
                    }
                    currentLightIndex = targetIndex; // Update current index for next path
                }
            }

            async function handleFullBoardPayoutBonus() {
                addHistory("Bonus Round: Full Board Payout (Sequential Hit)!");
                fullBoardSequence.start(); // Start bonus music

                // Shuffle slot items to hit them in a random order
                const shuffledSlotItems = [...slotItems];
                shuffleArray(shuffledSlotItems);

                let individuallyBlinkingFruits = []; // To track fruits that are blinking individually

                // Sequential hitting and individual blinking
                let currentLightIndex = slotItems.indexOf(shuffledSlotItems[0]); // Start from the first shuffled item

                for (let i = 0; i < shuffledSlotItems.length; i++) {
                    const targetFruitElement = shuffledSlotItems[i];
                    const targetIndex = slotItems.indexOf(targetFruitElement);

                    // Path from current light position to the next target, 1.5 cycles
                    const path = generateLongPath(currentLightIndex, targetIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75)); // Swift then slow
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    // Once the light hits, the fruit starts blinking individually
                    targetFruitElement.classList.add('highlight'); // Keep it highlighted
                    individuallyBlinkingFruits.push(targetFruitElement); // Add to the list for individual blinking

                    // Start individual blinking for this fruit
                    let fruitBlinkState = true;
                    const individualBlinkInterval = setInterval(() => {
                        fruitBlinkState = !fruitBlinkState;
                        if (fruitBlinkState) {
                            targetFruitElement.classList.add('highlight');
                        } else {
                            targetFruitElement.classList.remove('highlight');
                        }
                    }, 300); // Individual blink speed
                    targetFruitElement.dataset.individualBlinkId = individualBlinkInterval; // Store ID to clear later

                    await Tone.start();
                    synth.triggerAttackRelease("E5", "16n", Tone.context.currentTime); // Distinct hit sound
                    playFruitHitSound(fruitsData[targetFruitElement.dataset.fruit].category);
                    await new Promise(res => setTimeout(res, 100)); // Small pause after hitting

                    const hitFruitDataName = targetFruitElement.dataset.fruit;
                    const fruitCategory = fruitsData[hitFruitDataName].category;
                    const fruitInfo = fruitsData[hitFruitDataName];

                    if (selectedFruits[fruitCategory] && fruitInfo && fruitInfo.type !== 'lucky' && fruitInfo.type !== 'display') {
                        const bonus = calculateSingleFruitWin(hitFruitDataName, selectedFruits[fruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`üéâ SEQUENTIAL HIT ‚Üí ${fruitInfo.emoji} +KES ${bonus.toFixed(2)}`);
                    }
                    currentLightIndex = targetIndex; // Update current index for next path
                }

                fullBoardSequence.stop(); // Stop bonus music after all fruits are hit

                // After all 28 are done, clear individual blinks and start collective blinking
                addHistory("All fruits hit! Now blinking together.");
                individuallyBlinkingFruits.forEach(fruitEl => {
                    clearInterval(fruitEl.dataset.individualBlinkId);
                    fruitEl.classList.remove('highlight'); // Ensure they are off before collective blink
                });

                // Start collective blinking for all 28 fruits
                let collectiveBlinkState = false;
                bonusBlinkInterval = setInterval(() => { // Reuse global bonusBlinkInterval
                    collectiveBlinkState = !collectiveBlinkState;
                    slotItems.forEach((item, index) => { // All 28 fruits
                        if (collectiveBlinkState) {
                            item.classList.add('highlight');
                            bonusBlinkSynth.triggerAttackRelease("C6", "32n", Tone.context.currentTime + (index * 0.001)); // Higher pitch for collective
                        } else {
                            item.classList.remove('highlight');
                        }
                    });
                }, 400); // Collective blink speed
            }

            async function handleAllApplesBonusSequence() {
                addHistory("Bonus Round: All Apples Hit (excluding small x3)!");
                appleBonusMelody.start();
                // Filter for all items that belong to the 'apple' category, excluding 'small-apple-x3-top'
                const allAppleFruits = slotItems.filter(item =>
                    fruitsData[item.dataset.fruit]?.category === 'apple' && item.dataset.fruit !== 'small-apple-x3-top'
                );

                let currentLightIndex = slotItems.indexOf(slotItems[0]); // Start from a default position

                for (let appleEl of allAppleFruits) {
                    const targetLuckyFruitIndex = slotItems.indexOf(appleEl);
                    const path = generateLongPath(currentLightIndex, targetLuckyFruitIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75));
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    appleEl.classList.add('highlight');
                    hitFruitsForBlink.push(appleEl);

                    await Tone.start();
                    synth.triggerAttackRelease("E5", "16n", Tone.context.currentTime);
                    playFruitHitSound(fruitsData[appleEl.dataset.fruit].category);
                    await new Promise(res => setTimeout(res, 100));

                    const hitFruitDataName = appleEl.dataset.fruit;
                    const fruitCategory = fruitsData[hitFruitDataName].category;
                    const fruitInfo = fruitsData[hitFruitDataName];

                    if (selectedFruits[fruitCategory] && fruitInfo && fruitInfo.type !== 'lucky' && fruitInfo.type !== 'display') {
                        const bonus = calculateSingleFruitWin(hitFruitDataName, selectedFruits[fruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`üçè APPLE BONUS ‚Üí ${fruitInfo.emoji} +KES ${bonus.toFixed(2)}`);
                    }
                    currentLightIndex = targetLuckyFruitIndex; // Update current index for next path
                }
                appleBonusMelody.stop();
            }

            async function handleNormalSpin() {
                addHistory("NORMAL SPIN: Simulating Spin...");

                let currentHighlightIndex = Math.floor(Math.random() * slotItems.length);
                let spinCount = 0;
                const minFullCycles = 2;
                const extraSteps = Math.floor(Math.random() * slotItems.length * 0.8) + 5;
                const totalSpins = (minFullCycles * slotItems.length) + extraSteps;

                await Tone.start();
                movingOscillator.start();

                await new Promise(resolve => {
                    const animateSpin = () => {
                        const remainingSpins = totalSpins - spinCount;
                        let delay = 40;
                        if (remainingSpins < 10) {
                            delay = 40 + (10 - remainingSpins) * 10;
                        } else if (remainingSpins < 20) {
                            delay = 40 + (20 - remainingSpins) * 2;
                        }

                        if (spinCount > 0) {
                            const prevIndex = (currentHighlightIndex === 0) ? slotItems.length - 1 : currentHighlightIndex - 1;
                            slotItems[prevIndex].classList.remove('highlight');
                        }

                        slotItems[currentHighlightIndex].classList.add('highlight');

                        currentHighlightIndex = (currentHighlightIndex + 1) % slotItems.length;
                        spinCount++;

                        if (spinCount >= totalSpins) {
                            movingOscillator.stop();
                            let finalWinningIndex = (currentHighlightIndex === 0) ? slotItems.length - 1 : currentHighlightIndex - 1;
                            let winningFruitElement = slotItems[finalWinningIndex];
                            let winningFruitDataName = winningFruitElement.dataset.fruit;

                            // Determine if it's a BAR and if the 1% chance hits
                            const isBarHit = fruitsData[winningFruitDataName].category === 'bar';
                            const triggerBarBonus = isBarHit && (Math.random() <= 0.01); // 1% chance for BAR bonus

                            // Remove highlight from the spinning one before processing
                            winningFruitElement.classList.remove('highlight');
                            // Highlight the *actual* determined winning fruit
                            slotItems[finalWinningIndex].classList.add('highlight');


                            setTimeout(async () => {
                                if (triggerBarBonus) {
                                    addHistory(`BAR hit! Triggering BAR bonus (1% chance).`);
                                    await handleNormalSpinBarBonus(winningFruitElement, winningFruitDataName);
                                } else {
                                    // If not a BAR bonus, process as a normal win (could be a BAR that didn't trigger bonus, or any other fruit)
                                    await processNormalSpinWin(winningFruitDataName, winningFruitElement);
                                }
                                resolve();
                            }, 500);
                        } else {
                            setTimeout(animateSpin, delay);
                        }
                    };
                    animateSpin();
                });
            }

            // This function now handles the win for non-BARs or re-rolled non-BARs
            async function processNormalSpinWin(winningFruitDataName, winningFruitElement) {
                const fruitInfo = fruitsData[winningFruitDataName];
                const fruitCategory = fruitInfo.category;

                // Ensure the element is highlighted if it's the final winning fruit (after re-roll or normal hit)
                hitFruitsForBlink.push(winningFruitElement); // Now add it here for blinking

                // Check for the new X3 bonus condition (if it's a small x3 fruit and not a BAR)
                const isSmallX3Fruit = ['small-apple-x3-top', 'small-watermelon-x3-right', 'small-orange-x3-right', 'small-7-x3-bottom', 'small-mango-x3-bottom', 'small-star-x3-left', 'small-bell-x3-left'].includes(winningFruitDataName);

                if (isSmallX3Fruit && Math.random() < 0.10) { // 10% chance for X3 bonus
                    await handleX3SmallFruitBonus(winningFruitElement, winningFruitDataName);
                } else {
                    // Existing logic for normal spin win
                    if (fruitInfo && fruitInfo.type !== 'lucky' && fruitInfo.type !== 'display') {
                        if (selectedFruits[fruitCategory]) {
                            const win = calculateSingleFruitWin(winningFruitDataName, selectedFruits[fruitCategory]);
                            totalWinAmount += win;
                            const displayName = fruitDisplayNames[fruitCategory] || fruitCategory;
                            addHistory(`Normal Spin Win: ${displayName} ${fruitInfo.emoji} ‚Üí +KES ${win.toFixed(2)}`);
                            playFruitHitSound(fruitCategory);
                        } else {
                            const displayName = fruitDisplayNames[fruitCategory] || fruitCategory;
                            addHistory(`Normal Spin: ${displayName} ${fruitInfo.emoji} (Not Staked)`);
                        }
                    }

                    // Apply "Lucky" feature if lucky-tab is the main win
                    if (winningFruitDataName.includes('lucky-tab')) {
                        addHistory("Lucky Tab Hit! Initiating Bonus...");

                        const hits = Math.floor(Math.random() * 2) + 2; // 2‚Äì3 hits
                        const luckyHits = [];

                        const tempNonBarFruits = [...nonBarFruitDataNames];
                        const tempBarFruits = [...barFruitDataNames];
                        shuffleArray(tempNonBarFruits);
                        shuffleArray(tempBarFruits);

                        for (let i = 0; i < hits; i++) {
                            if (Math.random() <= 0.01 && tempBarFruits.length > 0) { // 1% chance for BAR
                                luckyHits.push(tempBarFruits.pop());
                            } else if (tempNonBarFruits.length > 0) {
                                luckyHits.push(tempNonBarFruits.pop());
                            } else if (tempBarFruits.length > 0) {
                                luckyHits.push(tempBarFruits.pop());
                            } else {
                                console.warn("Could not pick enough lucky fruits!");
                                break;
                            }
                        }

                        let currentLuckyFruitIndex = slotItems.indexOf(winningFruitElement); // Start from the lucky tab

                        for (let randHitDataName of luckyHits) {
                            const luckyFruitElement = slotItems.find(item => item.dataset.fruit === randHitDataName);

                            if (luckyFruitElement) {
                                const luckyMovingSynth = new Tone.Synth({
                                    oscillator: { type: "sine" },
                                    envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                                }).toDestination();
                                const movingSoundLoop = new Tone.Loop(time => {
                                    luckyMovingSynth.triggerAttackRelease("C4", "32n", time);
                                }, "16n").start(0);

                                const targetLuckyFruitIndex = slotItems.indexOf(luckyFruitElement);
                                const path = generateLongPath(currentLuckyFruitIndex, targetLuckyFruitIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                                for (let k = 0; k < path.length; k++) {
                                    const index = path[k];
                                    slotItems[index].classList.add('highlight');
                                    await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75));
                                    slotItems[index].classList.remove('highlight');
                                }
                                movingSoundLoop.stop();
                                movingSoundLoop.dispose();
                                luckyMovingSynth.dispose();

                                luckyFruitElement.classList.add('highlight');
                                hitFruitsForBlink.push(luckyFruitElement);

                                await Tone.start();
                                synth.triggerAttackRelease("E5", "16n", Tone.context.currentTime);
                                playFruitHitSound(fruitsData[randHitDataName].category);
                                await new Promise(res => setTimeout(res, 100));

                                const luckyFruitCategory = fruitsData[randHitDataName].category;
                                if (selectedFruits[luckyFruitCategory]) {
                                    const bonus = calculateSingleFruitWin(randHitDataName, selectedFruits[luckyFruitCategory]);
                                    totalWinAmount += bonus;
                                    addHistory(`üçÄ LUCKY HIT ‚Üí ${fruitsData[randHitDataName].emoji} +KES ${bonus.toFixed(2)}`);
                                } else {
                                    addHistory(`üçÄ LUCKY MISS ‚Üí ${fruitsData[randHitDataName].emoji} (Not Staked)`);
                                }
                                currentLuckyFruitIndex = targetLuckyFruitIndex;
                            }
                        }
                        Tone.Transport.stop();
                        await new Promise(res => setTimeout(res, 500));
                    }
                }
            }

            async function handleX3SmallFruitBonus(hitFruitElement, hitFruitDataName) {
                addHistory("X3 BONUS: Light scrolling and dancing fruits!");
                goButton.disabled = true;

                // Clear hitFruitsForBlink for this specific bonus sequence
                hitFruitsForBlink = [];

                // Phase 1: Dancing with Lights for 6 seconds
                slotItems.forEach(item => item.classList.add('dancing')); // Start all fruits dancing

                let blinkState = false;
                const allFruitsBlinkInterval = setInterval(() => {
                    blinkState = !blinkState;
                    slotItems.forEach((item, index) => {
                        if (blinkState) {
                            item.classList.add('highlight');
                            bonusBlinkSynth.triggerAttackRelease("C5", "32n", Tone.context.currentTime + (index * 0.001));
                        } else {
                            item.classList.remove('highlight');
                        }
                    });
                }, 200); // Faster blink for "dancing with lights"

                // Start dancing music
                dancingSequence.start(Tone.context.currentTime);

                await new Promise(res => setTimeout(res, 6000)); // Wait for 6 seconds

                // Stop dancing and blinking
                clearInterval(allFruitsBlinkInterval);
                dancingSequence.stop(); // Stop dancing music
                slotItems.forEach(item => {
                    item.classList.remove('dancing');
                    item.classList.remove('highlight'); // Ensure all highlights are off before final hit
                });

                // Phase 2: Final Hit and Bonus Award
                hitFruitElement.classList.add('highlight'); // Highlight the original hit fruit again
                hitFruitsForBlink.push(hitFruitElement); // Add to global blinking array for post-spin blinking

                await Tone.start();
                synth.triggerAttackRelease("F5", "16n", Tone.context.currentTime); // Distinct bonus hit sound
                playFruitHitSound(fruitsData[hitFruitDataName].category);
                await new Promise(res => setTimeout(res, 100));

                const bonusMultiplier = Math.floor(Math.random() * 11) + 10; // 10-20x
                const bonusAmount = currentBetAmount * bonusMultiplier; // Stake placed on that fruit's category
                totalWinAmount += bonusAmount;
                addHistory(`üåü X3 BONUS: ${fruitsData[hitFruitDataName].emoji} ‚Üí +KES ${bonusAmount.toFixed(2)} (${bonusMultiplier}x Stake)`);
            }

            async function handleNormalSpinBarBonus(hitFruitElement, hitFruitDataName) {
                addHistory(`BAR HIT! ${fruitsData[hitFruitDataName].emoji} ‚Üí Initiating BAR Bonus!`);
                goButton.disabled = true;

                // Clear any previous highlights and blinking
                slotItems.forEach(item => {
                    item.classList.remove('highlight');
                    item.classList.remove('dancing');
                });
                hitFruitsForBlink = []; // Reset for this bonus

                // 1. Calculate and add initial BAR win
                const barCategory = fruitsData[hitFruitDataName].category;
                if (selectedFruits[barCategory]) {
                    const barWin = calculateSingleFruitWin(hitFruitDataName, selectedFruits[barCategory]);
                    totalWinAmount += barWin;
                    addHistory(`BAR WIN: ${fruitsData[hitFruitDataName].emoji} +KES ${barWin.toFixed(2)}`);
                    playFruitHitSound(barCategory);
                } else {
                    addHistory(`BAR HIT: ${fruitsData[hitFruitDataName].emoji} (Not Staked)`);
                }

                // Keep the initial BAR highlighted for now, it will be added to hitFruitsForBlink later
                hitFruitElement.classList.add('highlight');
                // The hitFruitsForBlink will be populated by this function, including the initial BAR

                await new Promise(res => setTimeout(res, 500)); // Short pause after initial BAR hit

                // 2. Light moves 1.5 rounds and hits 1-3 random fruits
                const numHits = Math.floor(Math.random() * 3) + 1; // 1-3 random fruits
                // Filter out BARs and Lucky Tabs for subsequent hits
                const potentialRandomFruits = allBettableFruitDataNames.filter(name =>
                    fruitsData[name].category !== 'bar' && fruitsData[name].type !== 'lucky'
                );
                shuffleArray(potentialRandomFruits);

                let currentLightIndex = slotItems.indexOf(hitFruitElement); // Start light from the hit BAR

                for (let i = 0; i < numHits; i++) {
                    if (potentialRandomFruits.length === 0) {
                        addHistory("Warning: Not enough non-BAR fruits for subsequent hits!");
                        break;
                    }

                    const targetFruitDataName = potentialRandomFruits.pop();
                    const targetFruitElement = slotItems.find(item => item.dataset.fruit === targetFruitDataName);
                    if (!targetFruitElement) continue;

                    const targetIndex = slotItems.indexOf(targetFruitElement);
                    const path = generateLongPath(currentLightIndex, targetIndex, slotItems.length, 2.5); // Changed from 1.5 to 2.5

                    const tempMovingSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.05, release: 0.05 }
                    }).toDestination();
                    const movingSoundLoop = new Tone.Loop(time => {
                        tempMovingSynth.triggerAttackRelease("C4", "32n", time);
                    }, "16n").start(0);

                    for (let k = 0; k < path.length; k++) {
                        const index = path[k];
                        slotItems[index].classList.add('highlight');
                        await new Promise(res => setTimeout(res, k < path.length - 3 ? 25 : 75)); // Swift then slow
                        slotItems[index].classList.remove('highlight');
                    }
                    movingSoundLoop.stop();
                    movingSoundLoop.dispose();
                    tempMovingSynth.dispose();

                    targetFruitElement.classList.add('highlight'); // Keep highlight on the target
                    hitFruitsForBlink.push(targetFruitElement); // Add to blinking array

                    await Tone.start();
                    synth.triggerAttackRelease("E5", "16n", Tone.context.currentTime); // Distinct hit sound
                    playFruitHitSound(fruitsData[targetFruitDataName].category);
                    await new Promise(res => setTimeout(res, 100));

                    const hitFruitCategory = fruitsData[targetFruitDataName].category;
                    if (selectedFruits[hitFruitCategory]) {
                        const bonus = calculateSingleFruitWin(targetFruitDataName, selectedFruits[hitFruitCategory]);
                        totalWinAmount += bonus;
                        addHistory(`üéÅ BAR BONUS HIT ‚Üí ${fruitsData[targetFruitDataName].emoji} +KES ${bonus.toFixed(2)}`);
                    } else {
                        addHistory(`üéÅ BAR BONUS MISS ‚Üí ${fruitsData[targetFruitDataName].emoji} (Not Staked)`);
                    }
                    currentLightIndex = targetIndex; // Update current index for next path
                }

                // Finally, add the initial BAR hit element to hitFruitsForBlink so it blinks with the others
                hitFruitsForBlink.push(hitFruitElement);
            }


            // Helper function to get a path for the moving light
            function getPath(startIndex, endIndex, totalItems) {
                const path = [];
                let currentIndex = startIndex;

                const clockwiseDist = (endIndex - startIndex + totalItems) % totalItems;
                const counterClockwiseDist = (startIndex - endIndex + totalItems) % totalItems;

                let stepsToTake;
                let direction;

                if (clockwiseDist <= counterClockwiseDist) {
                    stepsToTake = clockwiseDist;
                    direction = 1;
                } else {
                    stepsToTake = counterClockwiseDist;
                    direction = -1;
                }

                for (let i = 0; i < stepsToTake; i++) {
                    currentIndex = (currentIndex + direction + totalItems) % totalItems;
                    path.push(currentIndex);
                }
                return path;
            }

            // Function to play a sound for a hit fruit
            function playFruitHitSound(fruitCategory) {
                const note = fruitHitSounds[fruitCategory];
                if (note) {
                    Tone.start().then(() => {
                        polySynth.triggerAttackRelease(note, "8n", Tone.context.currentTime);
                    }).catch(e => console.error("Tone.js audio start failed for fruit hit sound:", e));
                }
            }

            function addHistory(text) {
                const listItem = document.createElement('li');
                listItem.innerHTML = text;
                historyList.prepend(listItem);

                while (historyList.children.length > 10) {
                    historyList.removeChild(historyList.lastChild);
                }
            }

            // Initial setup
            initializeFruitButtons();
            updateDisplay();
        });
    </script>
</body>
</html>
ÔøΩ
